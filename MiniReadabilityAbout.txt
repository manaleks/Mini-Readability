Описание алгоритма.
Программа состоит из одного класса в модуле с тем же названием, что и проект – MiniReadability и исполняемого модуля Main.
После запуска программы через командную строку, Main запрашивает url: "Write URL".
Следующим сообщением пользователь вводит адрес сайта. С этим параметром-адресом в Main создаётся экземпляр класса MiniReadability. Больше ничего запускать не требуется, так как отработка всех методов предусмотрена на этапе инициализации.
Класс содержит:
   Три закрытые переменные: __url, __name_of_file, __text.
   Соответствующие геттеры: url, name_of_file, text.
   Метод __init__(url : str).
   7 методов класса __import_site(), __create_new_text_file, __create_text(), __make_text_beautiful(), __create_beautiful_filename(), __mega_replace(...) и статический search_text_between(...).

При инициализации __init__(url : str)  запускает методы __import_site()  и __create_new_text_file(). Это своеобразные input/output.
В методе __import_site() используется библиотека urllib, с помощью которой получаем HTML сайта. В этом же методе весь полученный код сайта записывается во внутреннюю переменную __text. Обрабатываются 2 обобщённых, упрощённых исключения: 
1. проблема с адресом сайта. Например при вводе параметра "ЭТО НЕ УРЛ" вместо url программа выдаст сообщение об ошибке url и завершит работу.
2. проблема с раскодировкой сайта из двоичного вида в str. Возможна на некоторых сайтах.

Все остальные методы относятся к обработке полученного HTML текста, лежащего в __text, и созданию текстового файла.
__create_new_text_file() запускает методы:  __create_beautiful_filename(), __create_text(), __make_text_beautiful(). Данные методы обрабатывают переменные __name_of_file и __text. После этого, они могут использоваться для создания текстового файла. Создаётся новый файл (или перезаписывается старый) с именем __name_of_file и содержимым __text.

Метод __create_beautiful_filename() передаёт переменной __name_of_file содержимое __url, а затем изменяет, чтобы имя подходило для создания документа. Оставить в имени слеши, как в примере "[CUR_DIR]/lenta.ru/news/2013/03/dtp/index.txt" оказалось невозможным, поскольку "/" в Windows является недопустимым символом для имени документа. Все недопустимые символы заменены на "_".

Метод __create_text() на самом деле не создаёт текст. Просто приятно звучит. В действительности данный метод выбирает нужные части HTML текста, вынимает всё из тегов типа <p>...</p>. Если результатом такой фильтрации является пустая строка, программа выводит в командной строке сообщение об этом и завершает работу без создания текстового документа.

Метод __make_text_beautiful() действительно делает текст прекрасным. Убирает лишние последствия __creat_text(), вроде пустых строк. Обрамляет ссылки, находящиеся в тексте в символы []. Затем метод за один проход по тексту разделяет абзацы дополнительной пустой строкой и устанавливает максимальную длину строки - 80 символов.

Так же в алгоритме используются вспомогательные методы: __mega_replace(marker_before, marker_after, marker_before_inside, marker_after_inside, mode="") – по входным параметрам данный метод заменяет содержимое между внешними маркерами на содержимое внутренних. Таким образом и происходит удаление всего лишнего, вне тегов с текстом. Так же, при введении параметра mode = "url" метод обрамляет содержимое символами [].

Метод __mega_replace(...) использует статический метод search_text_between(text, marker_before, marker_after, mode=0), который возвращает из заданного текста фрагмент между маркерами. mode = 0 => возвращает без маркеров, mode != 0 => с ними.

Код программы закомментирован на ломанном английском, пояснения кратко дублируются. Также в папке с программой находится небольшая UML-ка, где всё снова дублируется. Возможно, так будет удобнее.